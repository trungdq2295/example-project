String
	Essential whitespace là whitespace khi remove sẽ ảnh hưởng đến String
	Ví dụ "Hello World", khi remove whitespace sẽ thành "HelloWorld"
	Trailing whitespace is whitespace at the end of line
	In text block, adding \ at the end will skip the line break
	    \s mean to preserve all whitespace at the end of the line in addition to adding a space
	    escape quotes is allowed but not required
	    new line  = 1 whitespace
	    new line is required after the opening textblock
                Example:
                    String s = """
                                    """; // emptyStrng
                    String s = """      hello
                               """; // Not compiled, "hello" has to be in the second line
                starting """ followed by any number of white spaces and then a new line
	StringBuilder
	    can set capacity by function ensureCapacity(100); // 100 character
	    Does has function append, replace, insert and they can append/replace/insert specific string at specific index like append("abc",0,8)
	    setLength() will automatically add whitespace for the exceed index
	String, StringBuilder, and StringBuffer - all are final classes. so all the method of them are final method
	repeat, compareTo, transform
	strip() remove whitespace present at the beginning and at the end (spaces, tabs, newlines, and other whitespace characters).
	indent(n) is to add n whitespace at each line of text block and add linebreak at last line if it doesn't end with linebreak
    stripIndent() remove common indent whitespace at the begining
        Example:
            String text = """
                               line 1
                          line 2
                       line 3
                    """;
            String strippedText = text.stripIndent();
            System.out.println(strippedText);
            Output will be:
            line 1
            line 2
            line 3
            If we don't use indent it will be
                        line 1
                    line 2
                line 3

Switch
    the type which provide value, it uses yield to return value not "return" keywords
        It ok to have break in new switch type. It's just redundant
    Only String, byte, char, short, int, (and their wrapper classes Byte, Character, Short, and Integer), and enums can be used as types of a switch selector expression (aka switch condition/variable).
    boolean, long, float and double cannot be used.
    long, float, double, and boolean can never be used as a switch variable.
    default cannot be combined with any case expression in arrow function

Local variable
    is not automatically instantiated the value
    Class variable does
    In the case, we have so many overloading function with similar type like long,int,short,Integer
        Java pick the most specific method signature it can find in overloading
        promotion -> autoboxing -> datatype -> convert => so if we pass int value, it gonna be long function => Integer function => int function => short function
    Remember bit manipulation: x ^ ~x will always be -1.
    byte can hold the value from -128 to 127
    Integer create a pool for value from -127 to 128, the value outside of that range will be created a new object reference
        Integer.parseInt(string, 2)
            The second parameter is to use which format to parse this String. Here is binary String
            if Integer.parseInt(string, 10), then it will use decimal, 16 for hexical
    All compound assignment operators internally do an explicit cast (+=, -=, *=, /=, ...)
        char c = 1;
        c += 1; // still cast the result to char
    Boolean operator (==, !=) has more precedence than =

Array
    When converting from array to list, java use fix-length backed list. This means the list use an array implementation. updated value is allowed but removing or adding is not
    Array.compare() will return a positive number and the number will be the same as the difference in the number of elements in both array
        will print negative number if the first array element is smaller than the second array element
    Arrays.mismatch() return a index which is not the same in 2 array
        return -1 if no mismatch is found

Optional
    if you use Optional.of(null), it will throw NullPointerException
    if you call get() on an empty Optional, it will throw NoSuchElementException
    You cannot change the content of Optional object after creation
        Example: Optional<String> grade = Optional.empty();
                    grade.of("FAIL"); // not work, grade still an empty optional

Math
	Math.ceil return double
	Math.max/min return the type of parameter
	Math.pow return double
	
Date
    The new Date/Time API is in java.time package
	Day Light Saving
		On March, it will skip from 2 am to 3am ( it mean when hour reach 1:59 am, it immediately turn into 3am) and the offset also change (increase by 1),
	Instant Time
		return time at GMT + 0 (no time zone)
		allow adding/removing time but for units of DAY or smaller
	Period
	    start with P
		take the last chain as the value
			Example: Period.ofYear(1).ofMonth(6).ofDay(3)
				Value is 3 day not 1 year 6 month 3 day
		Period.between
		    Note that if the second date is before the first date, a minus sign is included in the output.
	Duration
	    start with PT
	    Does not convert hour to day
	        Example: Duration.ofHours(25) => PT25H
	    Only work with hour, minutes, second
	    Duration of 0 is printed as 0S and a Period of 0 is printed as 0D
	Remember
	    Period and Durations differ in their treatment of daylight saving time when added to ZonedDateTime. Duration will add an exact number of second while Period tries to maintain the local time
	    Example: consider adding a Period Day and a Duration Day to 18:00 on the evening before daylight saving
	        => Period: will be 18:00
	        => Duration: will be  19:00
	All the classes in packages java.time are immutable and thread-safe
	DateTimeFormatter in java.time.format
	    parse() method in DateFormat and Numberformat() throws java.text.ParseException so it must either be declared in throws clause or catch exception

Binary Search
    If the array is not sorted, then the result can't be defined until runtime

Sealed Class
	Permit clause is optional if class in the same file with sealed class
	Can only be extended with final, sealed, non-sealed class
	All permitted subtypes of a sealed type must either belong to the same package or to the same module

Records
	Can not extend the class, but can implement interface
	Compact constructor is concise form of constructor. Can be used to validate or modify the values of property. It will run after record instantiated
	It is implicit final -> can extend sealed interface
	If no constructor is provided, canonical constructor will be provided automatically
	have toString, equal method

Class
    First line of constructor is either this() or super()
    When a programmer does not define ANY constructor, the compiler inserts one automatically, the access modifier of which is same as constructor of the class.
    Sub class extend variable must be covariant
        Covariant mean type can be substituted by its subtype
        Remember: List<Integer> is not a subtype of List<Number> even though Integer is a subtype of Number.
    When instantiate an object, static block run (only once, if it has run before then wont run again) -> block run -> constructor
    Abstract class can have constructor, but can't be instantiated directly, need subclass
    When override a method, new or broader exception can't be declare
        java allow covariant return types, which means that an overriding method can have its return type as any subclass of the return type of the overridden method
        Overriding method is allowed to make the overridden method more accessible (from default to protected/public)
        Overriding method can remove throw exception clause but when instantiate an object point to super class which throw exception, you need to handle it
            Example:
                class Game{
                  public void play() throws Exception{
                    System.out.println("Playing...");
                  }
                }

                public class Soccer extends Game{
                   public void play(){
                      System.out.println("Playing Soccer...");
                   }
                   public static void main(String[] args){
                       Game g = new Soccer();
                       g.play(); // you need to handle the Exception here, either use try/catch or declare throws Exception at main method
                   }
        Check the method signature (method name and parameter list) if it's a valid overriden
        Overriding method is allowed to erase the generic type, but is not allowed to add generic type if overridden method doesnt have. And the reverse is not valid
            Example: if the overridden method has Set<Integer>, then the overriding method can use Set or Set<Integer>. But if overridden method has a Set, then the overriding method must also have Set (Set<Integer> is not valid)

    default constructor calls the no-args constructor of the super class.
        sub class's constructor couldn't throw exception which is sub class of exception of upper class
            Example:
                class A -> A() throw IOException {}
                class B extend A -> B() throw FileNotFoundException {} //Not compile
                class B extend A -> B() throw IOException {} // ok

    instanceof apply to null always return false
            Example: if(null instanceof A) /// gonna be false
        Concrete class is a class that can be instantiated and used directly to create object unlike abstract or interface
        Inner class
            You can't apply an access modifier to inner class inside a method
    From sub class to super class, you don't a cast. However, you need if you convert from super class to class
        Example:
            B extend A
            A a = new A();
            B b = new B();
            a = b; // ok
            b = a; // no compile
            => b = (b) a; will compile but can cause exception due to a is an actual object of A not B
    Instance methods are overridden and variables (and static methods) are hidden. Which instance method is invoked depends on the class of th actual object, while which while field(and static method) is accessed depend on the datatype of the variable
        Static method are never overridden
    Java decide that old code should work exactly as it used to work before boxing-unboxing become available
        Example:
            void probe(int... x) { System.out.println("In ..."); }  //1
            void probe(Integer x) { System.out.println("In Integer"); } //2
            void probe(long x) { System.out.println("In long"); } //3
            void probe(Long x) { System.out.println("In LONG"); } //4
            public static void main(String[] args){
                Integer a = 4; new TestClass().probe(a); //5
                int b = 4; new TestClass().probe(b); //6
            }
            For line 5, java will go to line 2
            but for live 6, java will go to line 3 first. if line 3 is removed/commented out, then it will go to varargs - line 1
    The static block will run if only the class is instantiated active but not run in passive case
        Example:
            class Super { static String ID = "QBANK"; }
            class Sub extends Super{
               static { System.out.print("In Sub"); }
            }
            public class Test{
               public static void main(String[] args){
                  System.out.println(Sub.ID); // In sub won't be printed because the ID is belong to Super class
               }
            }
    Null reference maybe used to access a static variable without causing exception
    Remember, java will throw java.lang.ExceptionInInitializerError if init class is having exception (evenwhen it's not java.lang.ExceptionInInitializerError)
    Field are not overridden but shadowing ( mean hide the field from the super class when you redeclare that field in subclass)
    Any class is extend from super class mean its data type is the superclass
        Example: class ABC {} class BCD extends ABC{}
         => BCD is-a ABC

Interfaces
    Java allow sub interface to override static function in super interface by convert the static to default but not allowed to sub interface override default method in super interface by using static method at sub interface
        Example:
            interface Measurement {
                static int getBreadth() { return 0; } // Static method
            }

            interface Size extends Measurement {
                default int getBreadth() { return 10; } // Valid: Redeclare static method as a default method
            }

            interface Measurement {
                default int getLength() { return 0; } // Default method
            }

            interface Size extends Measurement {
                static int getLength() { return 10; } // Error: Cannot override a default method with a static method
            }
    Static method of an interface are not inherited in the same way by an implementing class.
    Sub Interfaces can redeclare the method from super interface

Enum
    Enum constructor is private
    It's legal to change value of enum (not recommend)
    Every enum implements Comparable and the natural order of enums is the order in which they are defined
    Enum can implement interface but can not extend or be extended since it's an final class
    You cannot override the clone method in an enum because java.lang.Enum makes it final
    You can add field to enum without having constructor for it, the field will be default value (example: null for object)
    ordinal() value start with 0 ( for the first enum)

Var
    var must be used for all variable in lambda expression
        (var a, b) -> ... //This is not valid
    are not allow in compound declaration
        Example: var a = 10, b= 10; // no allow

Exception
    When we have multiple catch block, and only 1 catch  block can catch the exception at a time, even when inside that catch block throw exception, it won't run into another catch
    close() method in Closeable can not throw exception, autocloseable can
    Exception
        in close() method will be supressed (overridden) by other exception in try with resources
        in multi catch can't be subclassed of each other
        in catch block will be overridden by exception thrown in finally //n no suppressed exception in this try,catch
        the exception in catch block is implicit final so you can't assign to new value
        Example
            try{

            } catch( FileNotFoundException e){ // e is implicit final, you can't assign e to new value such as e = New Exception(), this will cause compilation error

            } finally{
                throw IOException
            }
            FileNotFound will be overridden by IOException
    -g:vars is used to debug but for the left only
        Example: int x = (Integer) null; // It doesn't help here since Integer null is on the right
            Integer x = (Integer) null;
            x.intValues() // help to trace the exception null pointer point to variable x
    try with resources
        The flow will be -> try -> close() ( in reverse order) -> catch -> finally
        Any exception that is thrown while closing a resource, is added to the list of suppressed exceptions to the exception thrown while opening a resource (or thrown from the try block.)
            Remember that, if method always caught/throws exception which throws in try, catch,finally block
        Once the resource is closed, calling the resource will throw ioexception
    ClassNotFoundException and NoSuchFieldException are checked exceptions
    DateTimeException extend from RuntimeException so you don't need to handle it
    When you declare checked exception in catch block, then your method need to have possibility of throwing that exception. If not, code won't be compiled

Array & Collection
    The wildcard ? shouldn't be used when instantiate collection
    In set, element are unordered so it doesn't have index like Array, ArrayList
    Hashset does not commit order. It works like HashMap
    When you create array, make sure to add size when creating without braces
        Example: String[] a = new String[5] ;// This is correct
            String[] a = new String[] ; This is not correct
            String[] a = new String[] {"abc"}; //This is correct
    Comparator.reverseOrder() does not implement Comparator interface
    NavigableMap<K,V>
        tailMap(K fromKey, boolean inclusive) returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey.
    Collections.unmodifiableList
        returns an unmodifiable view into the underlying List. It means if the root list is updated, the view point from unmodifiableList change too
    ArrayDeque
        work like Stack ( First In Last Out) and Queue(FIFO) so it has both method of stack and queue
        does have add() - add element to the end
           push - add element to the top
           remove - remove element at the top
    Collection.sorts(collectionX) => in this case, class of objects contained in the collection must implement Comparable interface.
    Collection.sorts(collectionX, ComparatorX) => in this case, the ComparatorX implement interface Comparator is used
        If the comparatorX is null, then it use natural sort
    List.of or Arrays.copy() doesn't support null so it will throw nullpointerexception if there's null element
    Collection.replaceAll() require a UnaryOperator param
    Comparable has compareTo(T t) method
    Comparator has compare(T t1, T t2) method
    TreeSet
        If the object doesn't implement Comparable interface, it will throw ClassCastException
        The subSet backed by original set. so if you insert or remove an element from the subset, the same will be reflected on the original set.
            However, if the subset is created using a range (fromElement to toElement), the element that you are inserting must fall within that range. If no, then the IllegalArgumentException will be thrown
                Example: TreeSet<Integer> sub = s.subSet(326, true, 328, true );
                        sub.add(329); //this will throw IllegalArgumentException due to 329 is larger than 328
    The sublist() return a view which is not affect the original list
    HashMap
        computeIfPresent() take BiFunction and will replace the value with that key

Stream
    IntStream convert to parallelStream should be using boxed().parallel()
        When using sum, it returns an int
    PartitioningBy will return a map with key true and false even when it has no value in key
    Parallel Stream
        Shouldn't represent stateful operation. For example: edit a value such as Collection
    flatMapToInt require IntStream as function parameter
    Reduction
        takes a sequence of input elements and combines them into a single summary result
            => filter() is not reduction
            => min, max, reduce are
        One-argument reduce() return Optional
        concurrent reduction need to be performed on parallel stream
    forEachOrdered() only applied at the end so the intermediate operation will still take advantages of parallel stream
    Deferred Execution mean the lambda expression will not be evaluated until runtime, but it still compiles
    SplitIterator will split a stream into a half at the middle
        Example: 1,2,3,4
            split => (1,2) and (3,4)
        When you split a Spliterator, the first half goes to the resulting ( new spliterator) while the remaining half remain with the origin one
            Example:
                 List<Integer> li = List.of(3, 7, 2, 1, 4, 6, 5, 8);
                 Spliterator<Integer> sit1 = li.spliterator();
                 Spliterator<Integer> sit2 = sit1.trySplit()
                    sit1 will be 4658
                    sit2 will be 3721
    findFirst() always returns the first element in ordered stream and parallel stream. but it's free to return anything in unordered stream
    In Stream, it will convert to Object value unlike primitive stream
    Primitive Stream
        Doesn't have get() but getAsDouble() or getAsLong()
        The average method of all numeric streams (IntStream, LongStream, DoubleStream) returns an OptionalDouble
    When use Stream.concat(), we need to use stream not primitive stream
    average() return a optional => can throw NoSuchElementException
    Collecting to Map
        When collecting to map and there's a duplicated key, it will throw java.lang.IllegalStateException if you use Collector.toMap(Function<T> f1, Function<T> f2)
        If you expect a duplicate source, you should use Collectors.toMap(Function, Function, BinaryOperator)
            Example:IntStream.range(0, tickers.size())
                        .boxed()
                        .collect(Collectors.toMap(i -> tickers.get(i),
                                         i -> 1.0/ratio.get(i),
                                         (x, y) -> x+y)) // this line is to define what we gonna do if the key is duplicated. In this case, we will get the sum of 2 values
        Collectors.groupingBy expects all keys to be non-null. If there's a null, it will throw NullPointerException
            Should use Optional.ofNullable for the case null key, and can use maps.get(Optional.empty()) to retrieve data from that key
    Collectors.joining(",", "-", "+")
        In this case, it has 3 parameter. It means it separates each character with , and start with - and end with +
    We do have Collector.filtering(Predicate, mapping function here)

Executor
    scheduledWithFixedDelay and scheduledAtFixedRate required 4 parameter (runnable, initial delay long, period long, timeunit) and it required ScheduleExecutorService to run not ExecutorService
    Remember in Executors.newCachedThreadPool()
        Runnable and Callable will use submit() not execute
    Even if a thread receive an InterruptedException, it is still in Runnable state. The state will be terminated once it's over

Functional Interface
    Parameter and return type has the same data type ( the same as IntFunction, LongFunction, DoubleFunction)
    IntFunction take an int parameter and return int value
        avoid additional associated cost of boxing/unboxing
    When UnaryOperator is used without generic argument, the provided type will be Object

Lambda & Method references
    We can use variable effective final as method reference
        Example: var s = "abc";
            Predicate<String> predicate = s::contains (valid)
    The variable which used in lambda & method references should be final or effective final

Module
    Modular JDK is helpful in improving performance of an application.
    A module jar is no different from a regular jar. It contains classes in the same structure and so, it can be used as a regular jar in a non-modular application.
    A service consists of the interfaces, any classes the interfaces reference, and a way to look up implementation
    A named module must be on module path and contains module-info.java
    An automatic module must be on module path but doesn't have module-info.java
    An unnamed module must be on class path
    "exports" should reference package name not module name
    "requires" references module name
    If a request is made from an automatic module to load a type whose package is not defined in any known module then the module system will attempt to load it from the classpath.
    When a module is on module path without module-info, all packages are exported
    module on module path can't access anything in classpath
    You can't have more than 1 provides in module
    java.lang is package
    java.base is available for all modules
        Remember java.util is not a module but a package which is inside java.base
    If a package is available in a jar on the classpath as well as in another jar on the module-path, the one on the classpath is ignored
    When running a  module ( with java cmd), module name should be before package name and then class
        Example: com.eu/com.eu.test.Example
        Remember that to run a module, you need --module-path and --module options.
    Migration
        The module from the top depends on the  module which is under them
        => top-down migration is to start from the module at top which has no module depend on, to the btm
        => bottom-down migration is to start from the module at bottom which has module depend, to the top module which has no module depend on
        Top-down migration will move all the module to the module path, all of them will be automatic module
        and then move 1 by 1 to a named module

    Service provider interface, service provider, consumer, service locator
                W --> X
                 \ /  ^
                 / \   |
                Y <-- Z
        X = Service provider interface
        Z = Service locator
        Y = Service Provider
        W = Consumer
        All parts of modules depend on service provider interface
        Consumer depends on service provider and service locator
            => 2 requires in module-info
        Service locator depends on service provider interface directly and service provider indirectly, contains load methods
            => contains 3 parts: exports, requires, uses
            => requires the service provider interfaces and export the packages with the locator
            =>  "uses" specifies the service provider interfaces it references
            Remember ServiceLoader implement java.lang.Iterable
        Service provider depend on service provider interface
            => 1 require and 1 provides
            if service provider has public st atic provider() method then it is not required for the service provider to be a subtype of the service type. Only the provider method should return subtype of the service type
    Command
        -d = describle module
        -m = --module foo.bar
            used to run or compiled only specific module
            By using --module option, you are telling the compiler that you want to compile foo.bar module. It will look for foo.bar directory under the src and compile all the java files stored anywhere under the src/foo.bar directory
        -s = --sumary
        -p = --module-path
            used to specify the paths where java or javac will look for module definitions
            The path can be a directory where jar files and exploded module classes are stored. It can also be a path to individual jar files that contain module files.
            Example: java -p c:\modules\movies.jar
        --show-module-resolution
            show all the dependencies of a module and how they are resolved while execution of a class
        --output flag provides desired destination to output file in PC
        --module-source-path require output directory
            Example: javac --module-source-path src -d out --module foo.bar
            It will create class filed under the out path
        jmod command: create, extract, describe, list, hash
            used to package module file into jmod archives
            describe: use to identify class and module dependencies
        jlink use to create java image
            generate a directory with folder for runtime image
            includes the modules in --add-modules itself
        javac take command -p not -m
        jdeps command output : requires mandated java.base
            used to find out all dependencies of a class or a jar file
            without any command, jdeps list packages and modules dependencies.
            With -s, it provides a summary and omit the package name
            -jdkinternal/--jdk-internal includes table of suggestion if any internal API is used in JAR
            does not execute any classes/modules. It only inspects the code. Thus, it cannot find out dependencies that are created due classes loaded at run time using reflection API.
            goes with command: -cp/-classpath/--class-path: Used to include dependent non-modular jar file
            --list-deps: will list all the modules on which module depends and it will show an error if module requires any other application module

Concurrent
    Thread.run() make the program run single threaded
    Callable define call() not run()
    Live lock is special case of resource starvation
    Need to read CyclicBarrier, Lock/Reentrant lock
    Cyclic Barrier
        is to have the required number of thread to unlock and then run the callback. if the number of thread doesn't reach the required, it will be hanged ( cause deadlock)
            Example: var cyclic = new CyclicBarrier(4, () -> System.out.println("abc")
                Explain: after it reach 4 thread, it will run system.out

    ConcurrentSkipListsSet and ConcurrentSkipListMap is sorted concurrent collections
    Runnable can return null for return type void
    synchronized in function block need to have an object so it can lock
        Example:
        public void abc(){
            synchronized (this){ // Compile

            }

        }
        public void abc(){
            synchronized{// not compile

            }

        }
    Synchronize on class level and on object level are not the same
    HashMap supports adding null key as well as null values but ConcurrentHashMap does not.
    Intrinsic lock is a  synchronization which is built around an internal entity
    A thread is said to own the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire it. Other thread will block when it attempts to acquire the lock
Java IO
    When you try to read an object from an ObjectInputStream using ObjectInputStream's readObject() method, it will check whether the class, which is being read, implements readObject method()
        If it does, then the class's readObject will be invoked first
        readObject() throws ClassNotFoundException so it has to be caught by catch block or throws by method
    File
        doesn't have get() but of() method
        A file or directory doesn't need exist to create a File object
    Files
        doesn't have of() but get() method
        Should not copy to the existing Files/Directories ( can do if we have option override)
        Files.readAllFiles() return a List<String>
        Files.walk() return a Stream<String>
        Files.isSameFile throw an exception if file is not
            It doesn't check the content of 2 files but the paths that 2 paths object resolve the same file or not
        Files.list() iterate all files in a single directory
        Files.mismatch() compare case sensitive so h & H is not the same
        Files.line(Paths.get(filePAth)) return a Stream<String>// Files.line require a Path
        Files.readAllLines(Paths.get(filePath)) return a List<String>
        Files.find(Path start, int maxDepth, BiPredicate matcher, options)
            uses to find a Files in a Path
            Can go inside directory as much as maxDepth
            return a Stream<Path>
    Console
        Constructor new Console() is private. Should use Console c = System.console()
        If your application is run in the background by a scheduler, then System.console() will return a null
    BufferWriter
        require wrapper
        Does not have writeUTF method
    BufferReader
        can be created by using
            + new BufferedReader(new FileReader(fullFilePath));
            + new BufferedReader(new FileReader( new File(fullFilePath)));
        Can be used to read String by using readLine() method
    Writer
        is an abstract class not interface
        PrintWriter
            write method writes a single character to the file. THe size in bytes of characters depend on the default character encoding of the underlying platform.
            Example:
                    OutputStream os = new FileOutputStream(name)
                    var pw = new PrintWriter(os);
                    pw.write(1);
            none of the PrintWriter's method throw any I/O exception because they suppress the errors in writing and set an internal flag for error status
            Doesn't have write<Primitive> method
            It does have write(String), write(int), write(char[]) methods.
            It also has write(char[] buf, int off, int len) and write(String buf, int off, int len) methods that let you write a portion of the input buf
        FileWriter
            will create a new empty file if the file does not exist
        OutputStream
            write(int i) method of various stream based classed such as FileOutputStream take an int parameter but write only low 8bit (1 byte)) of that integer
    FileReader
        required file to be existed if not, it will throw FileNotFoundException
    p1.resolve(p2)
        if p2 is an absolute path => return p2
        if p1 is absolute path and p2 is an relative path => return p1 append p2
        if p1 and p2 are absolute path => return p1 append p2
    p1.relativize(p2)
        both p1 and p2 should be either relative or absolute
        If not or different root, then it will throw IllegalArgumentException
    p1.resolveSibling(p2)
        This is good if the file you want to access is in the same directory of file in p1
    If System.err is closed, no exception will be thrown even when there's exception
    FileInput
        doesn't have readLine-
    Path
        index star from 0
        if getName() method with the index is larger than the actual length, it will throw illegalArgumentException
    Paths
        getRoot() will return root component of the path
            For example :
                Path p1 = Paths.get("c:\\main\\project\\Starter.java")
                String root = p1.getRoot().toString() // this return c:\
                Path p2 = Paths.get("Starter.java")
                String root = p2.getRoot().toString() // this return null
    Constructor of the class for an object being deserialized is never invoked except for record classes. This is secure because record class can validate the values before assign them to field
    System.out
        never throw IOException when data's written to it
        all characters printed by System.out are converted into bytes using the given encoding or charset, or platform' default if not specific
    DirectoryStream<Path> ds = Files.newDirectoryStream(dir, "*.{gif,jpeg} // to read all the file with extension gif, jpeg
    Serialize/Deserialize
        When deserialize a class which is aio sub class of a class no implement Serialize, that upper class require no-argus constructor.
            If it doesn't has, when deserialize, program will throw InvalidClassException exception
    substring(startIndex, endIndex)
        The root (c: or d: ) is not considered as the beginning
        The data at endIndex will be exclude
    RandomAccessFile
        var raf = new RandomAccessFile("c:\\temp\\test.txt", "rwd");
        If the file test does not exist, an attempt will be made to create it.

Database
    You can use setNull but it required you to set datatype
    Driver is responsible for getting connection to Database
    if store procedure return value, should use execute()
    It's ok to set param 1 and executeUpdate() 2 times
        Example
            var sql = "INSERT INTO abc(color,name) values (?,?)"
            var st = conn.prepareStatement(sql)
            st.setString(1,"234");
            st.setString(2,"abc");
            st.executeUpdate();

            st.setString(1,"456");
            st.executeUpdate(); /// still work with value 1 is 456 and 2 is abc
    When in auto commit mode, the statement commit immediately evenwhen you set the auto commit to false before and then set it to true
    ResultSet doesn't has hasNext() method but next() method
        ResultSet have absolute(n) method to skip the read to line n
        When we get the result from ResultSet, and use it to update the value in DB which's in result set, the data won't be affect
            Example:
                Connection c = ds.getConnection(); //assume that ds refers to a DataSource
                Statement stmt = c.createStatement();
                String qr = "select * from PERSON";
                try(ResultSet rs = stmt.executeQuery(qr);
                PreparedStatement ps1 =
                c.prepareStatement("update PERSON set taxid = 'NNNN' where id=?");      )   {
                      while(rs.next()){
                                 int id = rs.getInt(1);
                                ps1.setInt(1, id);
                                ps1.executeUpdate(); //1
                                System.out.println("Updated "+rs.getString(3)); //2
                                }
                }
                We tried to access the data from DB and set to update again, the data in result set won't be affected
    execute() return boolean unlike executeQuery() return ResultSet
    Connect to DB with username/password
    Properties p = new Properties();
    p.setProperty("user", userid);
    p.setProperty("password", pwd);
    Connection c = DriverManager.getConnection(dburl, p)
    Remember
        callableStatement.setString("NAME", "john",java.sql.Types.VARCHAR); //valid
        callableStatement.setString(1, "john",java.sql.Types.VARCHAR); //valid, //because it is inherited from PreparedStatement

        preparedStatement.setString("NAME", "john",java.sql.Types.VARCHAR); //will NOT compile
        preparedStatement.setString(1, "john",java.sql.Types.VARCHAR); //valid
    Statement's enquoteLiteral method returns a String enclosed in single quotes. Any occurrence of a single quote within the string will be replaced by two single quotes. This prevents SQL injection attacks
        Example:
            String qr = "SET SESSION sql_mode = '"+mode+"';"
            can replace with
                String qr = "SET SESSION sql_mode = "+stmt.enquoteLiteral(mode)+";";


Localization
    Resource Bundle
        The resource gonna use request locale
            If it have, it move from request locale -> requested language code -> default properties
            IF it doesn't have, it move to default locale -> default language code locale -> default properties
            If there's any properties match the request and default, it will throw exception once you call getBundle()
    Oracle defines locales as geographical, political, cultural region
    CompactNumberFormat round number to nearest
    Properties file
        Java move from requested locale (language code and region) to requested language code to default locale to default language locale code to non-locale file
    There's DateTimeFormatter not DateFormatter.
        DateTimeFormatter can format datetime, date but not time
        You need to escape the text if you put it in format pattern. Use  ' to do that
            Example: String s = "'abc' yyyy MM dd" //No Exception in runtime when format
                String s = " abc yyyy MM dd" // Exception in runtime when format
    Style.Short => Thousand = K, Million = M
    The option is to use for formatting text is Category.FORMAT
    You can use this method
        String[] vals =rb.getStringArray("key2");

Reference
    A declared reference variable exists regardless of whether a reference value (i.e. an object) has been assigned to it or not.
    Value of it based on the datatype it declared not the value instantiate
        Example: A extend B
            B b = new B()
            A a = (A) b
            => instance variable of b will belong to class B and instance variable of a value will belong to class A

Number
    Division by zero in int value will result as Exception but in Float, it result as  Float.POSITIVE_INFINITY or Float.NEGATIVE_INFINITY (or Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY

Pattern Variable
    When use this, you must use a subtype on the right hand side. If you use same type, the  code won't be compiled

Operand
    Java parses an expression from left to right. Once it realizes that the left operand of a conditional "or" operator has evaluated to true, it doesn't even try to evaluate the right side
    Ternary Expression is ( ? :)

Important Note on Casting
    public void saveObject(List e ){
         prevObject = e ;
         i++ ;
    }
    Then datatype of e should be List or subclass of List

String
	Essential whitespace là whitespace khi remove sẽ ảnh hưởng đến String
	Ví dụ "Hello World", khi remove whitespace sẽ thành "HelloWorld"
	Trailing whitespace is whitespace at the end of line
	In text block, adding \ at the end will skip the line break
	    \s mean to preserve all whitespace at the end of the line in addition to adding a space
	    escape quotes is allowed but not required
	    new line  = 1 whitespace

Switch
    the type which provide value, it uses yield not return

Local variable
    is not automatically instantiated the value
    Class variable does
    In the case, we have so many overloading function with similar type like long,int,short,Integer
        Java pick the most specific method signature it can find in overloadding

        promotion -> autoboxing -> datatype -> convert => so if we pass int value, it gonna be long function => Integer function => int function => short function

Array
    When converting from array to list, java use fix-length backed list. This means the list use an array implementation. updated value is allowed but removing or adding is not

Math
	Math.ceil return double
	Math.max/min return the type of parameter
	Math.pow return double
	
Date
	Day Light Saving
		On March, it will skip from 2 am to 3am ( it mean when hour reach 1:59 am, it immediately turn into 3am) and the offset also change (increase by 1),
	Instant Time
		return time at GMT + 0 (no time zone)
		allow adding/removing time but for units of DAY or smaller
	Period
		take the last chain as the value
			Example: Period.ofYear(1).ofMonth(6).ofDay(3)
				Value is 3 day not 1 year 6 month 3 day

Binary Search
    If the array is not sorted, then the result can't be defined until runtime

Class
    instanceof apply to null always return false
        Example: if(null instanceof A) /// gonna be false
    Concrete class is a class that can be instantiated and used directly to create object unlike abstract or interface

Sealed Class
	Permit clause is optional if class in the same file with sealed class
	Can only be extended with final, sealed, non-sealed class

Records
	Can not extend the class, but can implement interface
	Compact constructor is concise form of constructor. Can be used to validate or modify the values of property. It will run after record instantiated
	It is implicit final -> can extend sealed class

Class
    First line of constructor is either this() or super()
    Sub class extend variable must be covariant
    When instantiate an object, static block run (only once, if it has run before then wont run again) -> block run -> constructor
    Abstract class can have constructor, but can't be instantiated directly, need subclass
    When override a method, new or broader exception can't be declare
Enum
    Enum constructor is private
    It's legal to change value of enum (not recommend)
Var
    var must be used for all variable in lambda expression
        (var a, b) -> ... //This is not valid
Exception
    When we have multiple catch block, and only 1 catch  block can catch the exception at a time, even when inside that catch block throw exception, it won't run into another catch
    close() method in Closeable can not throw exception, autocloseable can
    Exception in close() method will be supressed (overridden) by other exception in try with resources
    Exception in multi catch can't be subclassed of each other
    Exception in catch block will be overridden by exception thrown in finally
        Example
            try{

            } catch( FileNotFoundException e){

            } finally{
                throw IOException
            }
            FileNotFound will be overridden by IOException
    -g:vars is used to debug but for the left only
        Example: int x = (Integer) null; // It doesn't help here since Integer null is on the right
            Integer x = (Integer) null;
            x.intValues() // help to trace the exception nullpointer point to variable x
    try with resources
        The flow will be -> try -> close() ( in reverse order) -> catch -> finally

Array & Collection
    The wildcard ? shouldn't be used when instantiate collection
    In set, element are unordered so it doesn't have index like Array, ArrayList
    Hashset does not commit order. It works like HashMap
    When you create array, make sure to add size when creating without braces
        Example: String[] a = new String[5] ;// This is correct
            String[] a = new String[] ; This is not correct
            String[] a = new String[] {"abc"}; //This is correct
    Comparator.reverseOrder() does not implement Comparator interface

Stream
    IntStream convert to parallelStream should be using boxed().parallel()
        When using sum, it returns an int
    PartitioningBy will return a map with key true and false even when it has no value in key
    Parallel Stream
        Shouldn't represent stateful operation. For example: edit a value such as Collection
    flatMapToInt require IntStream as function parameter
    Reduction
        One-argument reduce() return Optional
        concurrent reduction need to be performed on parallel stream
    forEachOrdered() only applied at the end so the intermediate operation will still take advantages of parallel stream
    Deferred Execution mean the lambda expression will not be evaluated until runtime, but it still compiles
    SplitIterator will split a stream into a half at the middle
        Example: 1,2,3,4
            split => (1,2) and (3,4)
    findFirst() always returns the first element in ordered stream and parallel stream. but it's free to return anything in unordered stream
    In Stream, it will convert to Object value unlike primitive stream
    Primitive Stream
        Doesn't have get() but getAsDouble() or getAsLong()
    When use Stream.concat(), we need to use stream not primitive stream

Executor
    scheduledWithFixedDelay and scheduledAtFixedRate required 4 parameter (runnable, initial delay long, period long, timeunit) and it required ScheduleExecutorService to run not ExecutorService


Function
    Parameter and return type has the same data type ( the same as IntFunction, LongFunction, DoubleFunction)
    IntFunction take an int parameter and return int value
    When UnaryOperator is used without generic argument, the provided type will be Object

Lambda & Method references
    We can use variable effective final as method reference
        Example: var s = "abc";
            Predicate<String> predicate = s::contains (valid)

Module
    A service consists of the interfaces, any classes the interfaces reference, and a way to look up implementation
    A named module must be on module path and contains module-info.java
    An automatic module must be on module path but doesn't have module-info.java
    An unnamed module must be on class path
    "exports" should reference package name not module name
    "requires" references module name
    When a module is on module path without module-info, all packages are exported
    module on module path can't access anything in classpath
    java.lang is package
    java.base is available for all modules
    When running a  module ( with java cmd), module name should be before package name and then class
        Example: com.eu/com.eu.test.Example
    Migration
        The module from the top depends on the  module which is under them
        => top-down migration is to start from the module at top which has no module depend on, to the btm
        => bottom-down migration is to start from the module at bottom which has module depend, to the top module which has no module depend on
        Top-down migration will move all the module to the module path, all of them will be automatic module
        and then move 1 by 1 to a named module

    Service provider interface, service provider, consumer, service locator
                W -->X
                 \ / ^
                 /\ |
                Y <-- Z
        X = Service provider interface
        Z = Service locator
        Y = Service Provider
        W = Consumer
        All parts of modules depend on service provider interface
        Consumer depends on service provider and service locator
            => 2 requires in module-info
        Service locator depends on service provider interface directly and service provider indirectly, contains load methods
            => contains 3 parts: exports, requires, uses
            => requires the service provider interfaces and export the packages with the locator
            =>  "uses" specifies the service provider interfaces it references
        Service provider depend on service provider interface
            => 1 require and 1 provides

    Command
        -d = describle module
        -m = -module
        -s = --sumary
        --output flag provides desired destination to output file in PC
        jmod command: create, extract, describe, list, hash
        jlink use to create java image
            generate a directory with folder for runtime image
            includes the modules in --add-modules itself
        javac take command -p not -m
        jdeps command output : requires mandated java.base
            without any command, jdeps list packages and modules dependencies.
            With -s, it provides a summary and omit the package name
            -jdkinternal/--jdk-internal includes table of suggestion if any internal API is used in JAR

Concurrent
    Thread.run() make the program run single threaded
    Callable define call() not run()
    Live lock is special case of resource starvation
    Need to read CyclicBarrier, Lock/Reentrant lock
    Cyclic Barrier
        is to have the required number of thread to unlock and then run the callback. if the number of thread doesn't reach the required, it will be hanged ( cause deadlock)
            Example: var cyclic = new CyclicBarrier(4, () -> System.out.println("abc")
                Explain: after it reach 4 thread, it will run system.out

    ConcurrentSkipListsSet and ConcurrentSkipListMap is sorted concurrent collections
    Runnable can return null for return type void
    synchronized in function block need to have an object so it can lock
        Example:
        public void abc(){
            synchronized (this){ // Compile

            }

        }
        public void abc(){
            synchronized{// not compile

            }

        }
    Synchronize on class level and on object level are not the same

Java IO
    File
        doesn't have get() but of() method
    Files
        doesn't have of() but get() method
        Should not copy to the existing Files/Directories ( can do if we have option override)
        Files.readAllFiles() return a List<String>
        Files.walk() return a Stream<String>
        Files.isSameFile throw an exception if file is not existed
        Files.list() iterate all files in a single directory
        Files.mismatch() compare case sensitive so h & H is not the same
    Console
        Constructor new Console() is private. Should use Console c = System.console()
    BufferWriter
        require wrapper
    Writer
        is an abstract class not interface
    p1.resolve(p2)
        if p1 is relative path and p2 is an absolute path => return p2
        if p1 is absolute path and p2 is an relative path => return p1 append p2
        if p1 and p2 are absolute path => return p1 append p2
    p1.relativize(p2)
        both p1 and p2 should be either relative or absolute
    If System.err is closed, no exception will be thrown evenwhen there's exception
    FileInput
        doesn't have readLine-

Database
    You can use setNull but it required you to set datatype
    Driver is responsible for getting connection to Database
    if store procedure return value, should use execute()
    It's ok to set param 1 and executeUpdate() 2 times
        Example
            var sql = "INSERT INTO abc(color,name) values (?,?)"
            var st = conn.prepareStatement(sql)
            st.setString(1,"234");
            st.setString(2,"abc");
            st.executeUpdate();

            st.setString(1,"456");
            st.executeUpdate(); /// still work with value 1 is 456 and 2 is abc
   When in auto commit mode, the statement commit immediately evenwhen you set the auto commit to false before and then set it to true
   ResultSet doesn't has hasNext() method but next() method
   execute() return boolean unlike executeQuery() return ResultSet

Localization
    Resource Bundle
        The resource gonna use request locale
            If it have, it move from request locale -> requested language code -> default properties
            IF it doesn't have, it move to default locale -> default language code locale -> default properties

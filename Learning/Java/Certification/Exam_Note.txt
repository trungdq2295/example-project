String
	Essential whitespace là whitespace khi remove sẽ ảnh hưởng đến String
	Ví dụ "Hello World", khi remove whitespace sẽ thành "HelloWorld"
	Trailing whitespace is whitespace at the end of line
	In text block, adding \ at the end will skip the line break
	    \s mean to preserve all whitespace at the end of the line in addition to adding a space
	    escape quotes is allowed but not required
	    new line  = 1 whitespace
	    new line is required after the opening textblock
                Example:
                    String s = """
                                    """; // emptyStrng
                    String s = """      hello
                               """; // Not compiled, "hello" has to be in the second line
                starting """ followed by any number of white spaces and then a new line
	StringBuilder
	    can set capacity by function ensureCapacity(100); // 100 character
	String, StringBuilder, and StringBuffer - all are final classes. so all the method of them are final method
	reapeat, compareTo, transform

Switch
    the type which provide value, it uses yield not return
    Only String, byte, char, short, int, (and their wrapper classes Byte, Character, Short, and Integer), and enums can be used as types of a switch selector expression (aka switch condition/variable).
    boolean, long, float and double cannot be used.
    long, float, double, and boolean can never be used as a switch variable.

Local variable
    is not automatically instantiated the value
    Class variable does
    In the case, we have so many overloading function with similar type like long,int,short,Integer
        Java pick the most specific method signature it can find in overloadding
        promotion -> autoboxing -> datatype -> convert => so if we pass int value, it gonna be long function => Integer function => int function => short function

Array
    When converting from array to list, java use fix-length backed list. This means the list use an array implementation. updated value is allowed but removing or adding is not
    Array.compare() will return a positive number and the number will be the same as the difference in the number of elements in both array
    Arrays.mismatch() return a index which is not the same in 2 array

Math
	Math.ceil return double
	Math.max/min return the type of parameter
	Math.pow return double
	
Date
    The new Date/Time API is in java.time package
	Day Light Saving
		On March, it will skip from 2 am to 3am ( it mean when hour reach 1:59 am, it immediately turn into 3am) and the offset also change (increase by 1),
	Instant Time
		return time at GMT + 0 (no time zone)
		allow adding/removing time but for units of DAY or smaller
	Period
	    start with P

		take the last chain as the value
			Example: Period.ofYear(1).ofMonth(6).ofDay(3)
				Value is 3 day not 1 year 6 month 3 day
		Period.between
		    Note that if the second date is before the first date, a minus sign is included in the output.
	Duration
	    start with PT
	    Does not convert hour to day
	        Example: Duration.ofHours(25) => PT25H
	    Only work with hour, minutes, second
	    Duration of 0 is printed as 0S and a Period of 0 is printed as 0D
	Remember
	    Period and Durations differ in their treatment of daylight saving time when added to ZonedDateTime. Duration will add an exact number of second while Period tries to maintain the local time
	    Example: consider adding a Period Day and a Duration Day to 18:00 on the evening before daylight saving
	        => Period: will be 18:00
	        => Duration: will be  19:00
	All the classes in packages java.time are immutable and thread-safe
	DateTimeFormatter in java.time.format

Binary Search
    If the array is not sorted, then the result can't be defined until runtime

Sealed Class
	Permit clause is optional if class in the same file with sealed class
	Can only be extended with final, sealed, non-sealed class

Records
	Can not extend the class, but can implement interface
	Compact constructor is concise form of constructor. Can be used to validate or modify the values of property. It will run after record instantiated
	It is implicit final -> can extend sealed class

Class
    First line of constructor is either this() or super()
    When a programmer does not define ANY constructor, the compiler inserts one automatically, the access modifier of which is same as that of the class.
    Sub class extend variable must be covariant
        Covariant mean type can be substituted by its subtype
    When instantiate an object, static block run (only once, if it has run before then wont run again) -> block run -> constructor
    Abstract class can have constructor, but can't be instantiated directly, need subclass
    When override a method, new or broader exception can't be declare
        java allow covariant return types, which means that an overriding method can have its return type as any subclass of the return type of the overridden method
        Overriding method is allowed to make the overridden method more accessible (from default to protected/public)
        Overriding method can remove throw exception clause
    default constructor calls the no-args constructor of the super class.
        sub class's constructor couldn't throw exception which is sub class of exception of upper class
            Example:
                class A -> A() throw IOException {}
                class B extend A -> B() throw FileNotFoundException {} //Not compile
                class B extend A -> B() throw IOException {} // ok

    instanceof apply to null always return false
            Example: if(null instanceof A) /// gonna be false
        Concrete class is a class that can be instantiated and used directly to create object unlike abstract or interface
        Inner class
            You can't apply an access modifier to inner class inside a method
    From sub class to super class, you don't a cast. However, you need if you convert from super class to class
        Example:
            B extend A
            A a = new A();
            B b = new B();
            a = b; // ok
            b = a; // no compile
            => b = (b) a; will compile but can cause exception due to a is an actual object of A not B
    Instance methods are overridden and variables (and static methods) are hidden. Which instance method is invoked depends on the class of th actual object, while which while field(and static method) is accessed depend on the datatype of the variable
    Java decide that old code should work exactly as it used to work before boxing-unboxing become available
        Example:
            void probe(int... x) { System.out.println("In ..."); }  //1
            void probe(Integer x) { System.out.println("In Integer"); } //2
            void probe(long x) { System.out.println("In long"); } //3
            void probe(Long x) { System.out.println("In LONG"); } //4
            public static void main(String[] args){
                Integer a = 4; new TestClass().probe(a); //5
                int b = 4; new TestClass().probe(b); //6
            }
            For line 5, java will go to line 2
            but for live 6, java will go to line 3 first. if line 3 is removed/commented out, then it will go to varargs - line 1

Enum
    Enum constructor is private
    It's legal to change value of enum (not recommend)
Var
    var must be used for all variable in lambda expression
        (var a, b) -> ... //This is not valid
Exception
    When we have multiple catch block, and only 1 catch  block can catch the exception at a time, even when inside that catch block throw exception, it won't run into another catch
    close() method in Closeable can not throw exception, autocloseable can
    Exception in close() method will be supressed (overridden) by other exception in try with resources
    Exception in multi catch can't be subclassed of each other
    Exception in catch block will be overridden by exception thrown in finally
        Example
            try{

            } catch( FileNotFoundException e){

            } finally{
                throw IOException
            }
            FileNotFound will be overridden by IOException
    -g:vars is used to debug but for the left only
        Example: int x = (Integer) null; // It doesn't help here since Integer null is on the right
            Integer x = (Integer) null;
            x.intValues() // help to trace the exception nullpointer point to variable x
    try with resources
        The flow will be -> try -> close() ( in reverse order) -> catch -> finally
        Any exception that is thrown while closing a resource, is added to the list of suppressed exceptions of the exception thrown while opening a resource (or thrown from the try block.)
            Example console:

        Any exception that is thrown while closing a resource is added to the list of suppressed exceptions of the exception thrown while opening a resource (or thrown from the try block.)

Array & Collection
    The wildcard ? shouldn't be used when instantiate collection
    In set, element are unordered so it doesn't have index like Array, ArrayList
    Hashset does not commit order. It works like HashMap
    When you create array, make sure to add size when creating without braces
        Example: String[] a = new String[5] ;// This is correct
            String[] a = new String[] ; This is not correct
            String[] a = new String[] {"abc"}; //This is correct
    Comparator.reverseOrder() does not implement Comparator interface
    NavigableMap<K,V>
        tailMap(K fromKey, boolean inclusive) returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey.
    Collections.unmodifiableList
        returns an unmodifiable view into the underlying List. It means if the root list is updated, the view point from unmodifiableList change too
    ArrayDeque
        work like Stack ( First In Last Out) and Queue(FIFO) so it has both method of stack and queue
        does have add() - add element to the end
           push - add element to the top
           remove - remove element at the top
    Collection.sorts(collectionX) => in this case, class of objects contained in the collection must implement Comparable interface.
    Collection.sorts(collectionX, ComparatorX) => in this case, the ComparatorX implement interface Comparator is used
    List.of or Arrays.copy() doesn't support null so it will throw nullpointerexception if there's null element

Stream
    IntStream convert to parallelStream should be using boxed().parallel()
        When using sum, it returns an int
    PartitioningBy will return a map with key true and false even when it has no value in key
    Parallel Stream
        Shouldn't represent stateful operation. For example: edit a value such as Collection
    flatMapToInt require IntStream as function parameter
    Reduction
        takes a sequence of input elements and combines them into a single summary result
            => filter() is not reduction
            => min, max, reduce are
        One-argument reduce() return Optional
        concurrent reduction need to be performed on parallel stream
    forEachOrdered() only applied at the end so the intermediate operation will still take advantages of parallel stream
    Deferred Execution mean the lambda expression will not be evaluated until runtime, but it still compiles
    SplitIterator will split a stream into a half at the middle
        Example: 1,2,3,4
            split => (1,2) and (3,4)
    findFirst() always returns the first element in ordered stream and parallel stream. but it's free to return anything in unordered stream
    In Stream, it will convert to Object value unlike primitive stream
    Primitive Stream
        Doesn't have get() but getAsDouble() or getAsLong()
    When use Stream.concat(), we need to use stream not primitive stream
    average() return a optional => can throw NoSuchElementException
    Collecting to Map
        When collecting to map and there's a duplicated key, it will throw java.lang.IllegalStateException if you use Colector.toMap(Function<T> f1, Function<T> f2)
        If you expect a duplicate source, you should use Collectors.toMap(Function, Function, BinaryOperator)
            Example:IntStream.range(0, tickers.size())
                        .boxed()
                        .collect(Collectors.toMap(i -> tickers.get(i),
                                         i -> 1.0/ratio.get(i),
                                         (x, y) -> x+y)) // this line is to define what we gonna do if the key is duplicated. In this case, we will get the sum of 2 values

Executor
    scheduledWithFixedDelay and scheduledAtFixedRate required 4 parameter (runnable, initial delay long, period long, timeunit) and it required ScheduleExecutorService to run not ExecutorService

Function
    Parameter and return type has the same data type ( the same as IntFunction, LongFunction, DoubleFunction)
    IntFunction take an int parameter and return int value
        avoid additional associated cost of boxing/unboxing
    When UnaryOperator is used without generic argument, the provided type will be Object

Lambda & Method references
    We can use variable effective final as method reference
        Example: var s = "abc";
            Predicate<String> predicate = s::contains (valid)

Module
    Modular JDK is helpful in improving performance of an application.
    A module jar is no different from a regular jar. It contains classes in the same structure and so, it can be used as a regular jar in a non-modular application.
    A service consists of the interfaces, any classes the interfaces reference, and a way to look up implementation
    A named module must be on module path and contains module-info.java
    An automatic module must be on module path but doesn't have module-info.java
    An unnamed module must be on class path
    "exports" should reference package name not module name
    "requires" references module name
    If a request is made from an automatic module to load a type whose package is not defined in any known module then the module system will attempt to load it from the classpath.
    When a module is on module path without module-info, all packages are exported
    module on module path can't access anything in classpath
    java.lang is package
    java.base is available for all modules
    When running a  module ( with java cmd), module name should be before package name and then class
        Example: com.eu/com.eu.test.Example
        Remember that to run a module, you need --module-path and --module options.
    Migration
        The module from the top depends on the  module which is under them
        => top-down migration is to start from the module at top which has no module depend on, to the btm
        => bottom-down migration is to start from the module at bottom which has module depend, to the top module which has no module depend on
        Top-down migration will move all the module to the module path, all of them will be automatic module
        and then move 1 by 1 to a named module

    Service provider interface, service provider, consumer, service locator
                W --> X
                 \ /  ^
                 / \   |
                Y <-- Z
        X = Service provider interface
        Z = Service locator
        Y = Service Provider
        W = Consumer
        All parts of modules depend on service provider interface
        Consumer depends on service provider and service locator
            => 2 requires in module-info
        Service locator depends on service provider interface directly and service provider indirectly, contains load methods
            => contains 3 parts: exports, requires, uses
            => requires the service provider interfaces and export the packages with the locator
            =>  "uses" specifies the service provider interfaces it references
        Service provider depend on service provider interface
            => 1 require and 1 provides
    Command
        -d = describle module
        -m = --module
            used to run or compiled only specific module
        -s = --sumary
        -p = --module-path
        -p = --module-path
            used to specify the paths where java or javac will look for module definitions
            The path can be a directory where jar files and exploded module classes are stored. It can also be a path to individual jar files that contain module files.
            Example: java -p c:\modules\movies.jar
        --show-module-resolution
            show all the dependencies of a module and how they are resolved while execution of a class
        --output flag provides desired destination to output file in PC
        jmod command: create, extract, describe, list, hash
            used to package module file into jmod archives
        jlink use to create java image
            generate a directory with folder for runtime image
            includes the modules in --add-modules itself
        javac take command -p not -m
        jdeps command output : requires mandated java.base
            used to find out all dependencies of a class or a jar file
            without any command, jdeps list packages and modules dependencies.
            With -s, it provides a summary and omit the package name
            -jdkinternal/--jdk-internal includes table of suggestion if any internal API is used in JAR
            does not execute any classes/modules. It only inspects the code. Thus, it cannot find out dependencies that are created due classes loaded at run time using reflection API.
            goes with command: -cp/-classpath/--class-path

Concurrent
    Thread.run() make the program run single threaded
    Callable define call() not run()
    Live lock is special case of resource starvation
    Need to read CyclicBarrier, Lock/Reentrant lock
    Cyclic Barrier
        is to have the required number of thread to unlock and then run the callback. if the number of thread doesn't reach the required, it will be hanged ( cause deadlock)
            Example: var cyclic = new CyclicBarrier(4, () -> System.out.println("abc")
                Explain: after it reach 4 thread, it will run system.out

    ConcurrentSkipListsSet and ConcurrentSkipListMap is sorted concurrent collections
    Runnable can return null for return type void
    synchronized in function block need to have an object so it can lock
        Example:
        public void abc(){
            synchronized (this){ // Compile

            }

        }
        public void abc(){
            synchronized{// not compile

            }

        }
    Synchronize on class level and on object level are not the same

Java IO
    File
        doesn't have get() but of() method
    Files
        doesn't have of() but get() method
        Should not copy to the existing Files/Directories ( can do if we have option override)
        Files.readAllFiles() return a List<String>
        Files.walk() return a Stream<String>
        Files.isSameFile throw an exception if file is not existed
            It doesn't check the content of 2 files but the paths that 2 paths object resolve the same file or not
        Files.list() iterate all files in a single directory
        Files.mismatch() compare case sensitive so h & H is not the same
    Console
        Constructor new Console() is private. Should use Console c = System.console()
    BufferWriter
        require wrapper
    Writer
        is an abstract class not interface
        PrintWriter
            write method writes a single character to the file. THe size in bytes of characters depend on the default character encoding of the underlying platform.
            Example:
                    OutputStream os = new FileOutputStream(name)
                    var pw = new PrintWriter(os);
                    pw.write(1);
    p1.resolve(p2)
        if p1 is relative path and p2 is an absolute path => return p2
        if p1 is absolute path and p2 is an relative path => return p1 append p2
        if p1 and p2 are absolute path => return p1 append p2
    p1.relativize(p2)
        both p1 and p2 should be either relative or absolute
    If System.err is closed, no exception will be thrown evenwhen there's exception
    FileInput
        doesn't have readLine-
    Path
        index star from 0
    Constructor of the class for an object being deserialized is never invoked except for record classes. This is secure because record class can validate the values before assign them to field
    System.out
        never throw IOException when data's written to it
        all characters printed by System.out are converted into bytes using the given encoding or charset, or platform' default if not specific
    DirectoryStream<Path> ds = Files.newDirectoryStream(dir, "*.{gif,jpeg} // to read all the file with extension gif, jpeg
    Serialize/Deserialize
        When deserialize a class which is a sub class of a class no implement Serialize, that upper class require no-argus constructor. If it doesn't has, when deserialize, program will throw InvalidClassException exception

Database
    You can use setNull but it required you to set datatype
    Driver is responsible for getting connection to Database
    if store procedure return value, should use execute()
    It's ok to set param 1 and executeUpdate() 2 times
        Example
            var sql = "INSERT INTO abc(color,name) values (?,?)"
            var st = conn.prepareStatement(sql)
            st.setString(1,"234");
            st.setString(2,"abc");
            st.executeUpdate();

            st.setString(1,"456");
            st.executeUpdate(); /// still work with value 1 is 456 and 2 is abc
    When in auto commit mode, the statement commit immediately evenwhen you set the auto commit to false before and then set it to true
    ResultSet doesn't has hasNext() method but next() method
        When we get the result from ResultSet, and use it to update the value in DB which's in result set, the data won't be affect
            Example:
                Connection c = ds.getConnection(); //assume that ds refers to a DataSource
                Statement stmt = c.createStatement();
                String qr = "select * from PERSON";
                try(ResultSet rs = stmt.executeQuery(qr);
                PreparedStatement ps1 =
                c.prepareStatement("update PERSON set taxid = 'NNNN' where id=?");      )   {
                      while(rs.next()){
                                 int id = rs.getInt(1);
                                ps1.setInt(1, id);
                                ps1.executeUpdate(); //1
                                System.out.println("Updated "+rs.getString(3)); //2
                                }
                }
                We tried to access the data from DB and set to update again, the data in result set won't be affected
    execute() return boolean unlike executeQuery() return ResultSet
    Connect to DB with username/password
    Properties p = new Properties();
    p.setProperty("user", userid);
    p.setProperty("password", pwd);
    Connection c = DriverManager.getConnection(dburl, p)

Localization
    Resource Bundle
        The resource gonna use request locale
            If it have, it move from request locale -> requested language code -> default properties
            IF it doesn't have, it move to default locale -> default language code locale -> default properties
    Oracle defines locales as geographical, political, cultural region
    CompactNumberFormat round number to nearest
    Properties file
        Java move from requested locale (language code and region) to requested language code to default locale to default language locale code to non-locale file
    There's DateTimeFormatter not DateFormatter.
        DateTimeFormatter can format datetime, date but not time
        You need to escape the text if you put it in format pattern. Use  ' to do that
            Example: String s = "'abc' yyyy MM dd" //No Exception in runtime when format
                String s = " abc yyyy MM dd" // Exception in runtime when format
    Style.Short => Thousand = K, Million = M
    The option is to use for formatting text is Category.FORMAT

Reference
    A declared reference variable exists regardless of whether a reference value (i.e. an object) has been assigned to it or not.
    Value of it based on the datatype it declared not the value instantiate
        Example: A extend B
            B b = new B()
            A a = (A) b
            => instance variable of b will belong to class B and instance variable of a value will belong to class A

Number
    Division by zero in int value will result as Exception but in Float, it result as  Float.POSITIVE_INFINITY or Float.NEGATIVE_INFINITY (or Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY

String
	Essential whitespace là whitespace khi remove sẽ ảnh hưởng đến String
	Ví dụ "Hello World", khi remove whitespace sẽ thành "HelloWorld"
	Trailing whitespace is whitespace at the end of line
	In text block, adding \ at the end will skip the line break
	    \s mean to preserve all whitespace at the end of the line in addition to adding a space
	    escape quotes is allowed but not required
	    new line  = 1 whitespace
	StringBuilder
	    can set capacity by function ensureCapacity(100); // 100 character

Switch
    the type which provide value, it uses yield not return
    long, float, double, and boolean can never be used as a switch variable.

Local variable
    is not automatically instantiated the value
    Class variable does
    In the case, we have so many overloading function with similar type like long,int,short,Integer
        Java pick the most specific method signature it can find in overloadding
        promotion -> autoboxing -> datatype -> convert => so if we pass int value, it gonna be long function => Integer function => int function => short function

Array
    When converting from array to list, java use fix-length backed list. This means the list use an array implementation. updated value is allowed but removing or adding is not
    Array.compare() will return a positive number and the number will be the same as the difference in the number of elements in both array
    Arrays.mismatch() return a index which is not the same in 2 array

Math
	Math.ceil return double
	Math.max/min return the type of parameter
	Math.pow return double
	
Date
	Day Light Saving
		On March, it will skip from 2 am to 3am ( it mean when hour reach 1:59 am, it immediately turn into 3am) and the offset also change (increase by 1),
	Instant Time
		return time at GMT + 0 (no time zone)
		allow adding/removing time but for units of DAY or smaller
	Period
		take the last chain as the value
			Example: Period.ofYear(1).ofMonth(6).ofDay(3)
				Value is 3 day not 1 year 6 month 3 day
		Period.between
		    Note that if the second date is before the first date, a minus sign is included in the output.
	Remember
	    Period and Durations differ in their treatment of daylight saving time when added to ZonedDateTime. Duration will add an exact number of second while Period tries to maintain the local time
	    Example: consider adding a Period Day and a Duration Day to 18:00 on the evening before daylight saving
	        => Period: will be 18:00
	        => Duration: will be  19:00



Binary Search
    If the array is not sorted, then the result can't be defined until runtime

Sealed Class
	Permit clause is optional if class in the same file with sealed class
	Can only be extended with final, sealed, non-sealed class

Records
	Can not extend the class, but can implement interface
	Compact constructor is concise form of constructor. Can be used to validate or modify the values of property. It will run after record instantiated
	It is implicit final -> can extend sealed class

Class
    First line of constructor is either this() or super()
    When a programmer does not define ANY constructor, the compiler inserts one automatically, the access modifier of which is same as that of the class.
    Sub class extend variable must be covariant
        Covariant mean type can be substituted by its subtype
    When instantiate an object, static block run (only once, if it has run before then wont run again) -> block run -> constructor
    Abstract class can have constructor, but can't be instantiated directly, need subclass
    When override a method, new or broader exception can't be declare
    instanceof apply to null always return false
            Example: if(null instanceof A) /// gonna be false
        Concrete class is a class that can be instantiated and used directly to create object unlike abstract or interface
        Inner class
            You can't apply an access modifier to inner class inside a method
    From sub class to super class, you don't a cast. However, you need if you convert from super class to class
        Example:
            B extend A
            A a = new A();
            B b = new B();
            a = b; // ok
            b = a; // no compile
            => b = (b) a; will compile but can cause exception due to a is an actual object of A not B
    Instance methods are overridden and variables (and static methods) are hidden. Which instance method is invoked depends on the class of th actual object, while which while field(and static method) is accessed depend on the datatype of the variable
    Java decide that old code should work exactly as it used to work before boxing-unboxing become available
        Example:
            void probe(int... x) { System.out.println("In ..."); }  //1
            void probe(Integer x) { System.out.println("In Integer"); } //2
            void probe(long x) { System.out.println("In long"); } //3
            void probe(Long x) { System.out.println("In LONG"); } //4
            public static void main(String[] args){
                Integer a = 4; new TestClass().probe(a); //5
                int b = 4; new TestClass().probe(b); //6
            }
            For line 5, java will go to line 2
            but for live 6, java will go to line 3 first. if line 3 is removed/commented out, then it will go to varargs - line 1

Enum
    Enum constructor is private
    It's legal to change value of enum (not recommend)
Var
    var must be used for all variable in lambda expression
        (var a, b) -> ... //This is not valid
Exception
    When we have multiple catch block, and only 1 catch  block can catch the exception at a time, even when inside that catch block throw exception, it won't run into another catch
    close() method in Closeable can not throw exception, autocloseable can
    Exception in close() method will be supressed (overridden) by other exception in try with resources
    Exception in multi catch can't be subclassed of each other
    Exception in catch block will be overridden by exception thrown in finally
        Example
            try{

            } catch( FileNotFoundException e){

            } finally{
                throw IOException
            }
            FileNotFound will be overridden by IOException
    -g:vars is used to debug but for the left only
        Example: int x = (Integer) null; // It doesn't help here since Integer null is on the right
            Integer x = (Integer) null;
            x.intValues() // help to trace the exception nullpointer point to variable x
    try with resources
        The flow will be -> try -> close() ( in reverse order) -> catch -> finally

Array & Collection
    The wildcard ? shouldn't be used when instantiate collection
    In set, element are unordered so it doesn't have index like Array, ArrayList
    Hashset does not commit order. It works like HashMap
    When you create array, make sure to add size when creating without braces
        Example: String[] a = new String[5] ;// This is correct
            String[] a = new String[] ; This is not correct
            String[] a = new String[] {"abc"}; //This is correct
    Comparator.reverseOrder() does not implement Comparator interface
    ArrayDequeue work like Stack ( First In Last Out)
    NavigableMap<K,V>
        tailMap(K fromKey, boolean inclusive) returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey.
    Collections.unmodifiableList
        returns an unmodifiable view into the underlying List. It means if the root list is updated, the view point from unmodifiableList change too

Stream
    IntStream convert to parallelStream should be using boxed().parallel()
        When using sum, it returns an int
    PartitioningBy will return a map with key true and false even when it has no value in key
    Parallel Stream
        Shouldn't represent stateful operation. For example: edit a value such as Collection
    flatMapToInt require IntStream as function parameter
    Reduction
        One-argument reduce() return Optional
        concurrent reduction need to be performed on parallel stream
    forEachOrdered() only applied at the end so the intermediate operation will still take advantages of parallel stream
    Deferred Execution mean the lambda expression will not be evaluated until runtime, but it still compiles
    SplitIterator will split a stream into a half at the middle
        Example: 1,2,3,4
            split => (1,2) and (3,4)
    findFirst() always returns the first element in ordered stream and parallel stream. but it's free to return anything in unordered stream
    In Stream, it will convert to Object value unlike primitive stream
    Primitive Stream
        Doesn't have get() but getAsDouble() or getAsLong()
    When use Stream.concat(), we need to use stream not primitive stream
    average() return a optional => can throw NoSuchElementException

Executor
    scheduledWithFixedDelay and scheduledAtFixedRate required 4 parameter (runnable, initial delay long, period long, timeunit) and it required ScheduleExecutorService to run not ExecutorService

Function
    Parameter and return type has the same data type ( the same as IntFunction, LongFunction, DoubleFunction)
    IntFunction take an int parameter and return int value
    When UnaryOperator is used without generic argument, the provided type will be Object

Lambda & Method references
    We can use variable effective final as method reference
        Example: var s = "abc";
            Predicate<String> predicate = s::contains (valid)

Module
    Modular JDK is helpful in improving performance of an application.
    A module jar is no different from a regular jar. It contains classes in the same structure and so, it can be used as a regular jar in a non-modular application.
    A service consists of the interfaces, any classes the interfaces reference, and a way to look up implementation
    A named module must be on module path and contains module-info.java
    An automatic module must be on module path but doesn't have module-info.java
    An unnamed module must be on class path
    "exports" should reference package name not module name
    "requires" references module name
    When a module is on module path without module-info, all packages are exported
    module on module path can't access anything in classpath
    java.lang is package
    java.base is available for all modules
    When running a  module ( with java cmd), module name should be before package name and then class
        Example: com.eu/com.eu.test.Example
        Remember that to run a module, you need --module-path and --module options.
    Migration
        The module from the top depends on the  module which is under them
        => top-down migration is to start from the module at top which has no module depend on, to the btm
        => bottom-down migration is to start from the module at bottom which has module depend, to the top module which has no module depend on
        Top-down migration will move all the module to the module path, all of them will be automatic module
        and then move 1 by 1 to a named module

    Service provider interface, service provider, consumer, service locator
                W --> X
                 \ /  ^
                 / \   |
                Y <-- Z
        X = Service provider interface
        Z = Service locator
        Y = Service Provider
        W = Consumer
        All parts of modules depend on service provider interface
        Consumer depends on service provider and service locator
            => 2 requires in module-info
        Service locator depends on service provider interface directly and service provider indirectly, contains load methods
            => contains 3 parts: exports, requires, uses
            => requires the service provider interfaces and export the packages with the locator
            =>  "uses" specifies the service provider interfaces it references
        Service provider depend on service provider interface
            => 1 require and 1 provides

    Command
        -d = describle module
        -m = --module
        -s = --sumary
        -p = --module-path
        --output flag provides desired destination to output file in PC
        jmod command: create, extract, describe, list, hash
        jlink use to create java image
            generate a directory with folder for runtime image
            includes the modules in --add-modules itself
        javac take command -p not -m
        jdeps command output : requires mandated java.base
            without any command, jdeps list packages and modules dependencies.
            With -s, it provides a summary and omit the package name
            -jdkinternal/--jdk-internal includes table of suggestion if any internal API is used in JAR

Concurrent
    Thread.run() make the program run single threaded
    Callable define call() not run()
    Live lock is special case of resource starvation
    Need to read CyclicBarrier, Lock/Reentrant lock
    Cyclic Barrier
        is to have the required number of thread to unlock and then run the callback. if the number of thread doesn't reach the required, it will be hanged ( cause deadlock)
            Example: var cyclic = new CyclicBarrier(4, () -> System.out.println("abc")
                Explain: after it reach 4 thread, it will run system.out

    ConcurrentSkipListsSet and ConcurrentSkipListMap is sorted concurrent collections
    Runnable can return null for return type void
    synchronized in function block need to have an object so it can lock
        Example:
        public void abc(){
            synchronized (this){ // Compile

            }

        }
        public void abc(){
            synchronized{// not compile

            }

        }
    Synchronize on class level and on object level are not the same

Java IO
    File
        doesn't have get() but of() method
    Files
        doesn't have of() but get() method
        Should not copy to the existing Files/Directories ( can do if we have option override)
        Files.readAllFiles() return a List<String>
        Files.walk() return a Stream<String>
        Files.isSameFile throw an exception if file is not existed
            It doesn't check the content of 2 files but the paths that 2 paths object resolve the same file or not
        Files.list() iterate all files in a single directory
        Files.mismatch() compare case sensitive so h & H is not the same
    Console
        Constructor new Console() is private. Should use Console c = System.console()
    BufferWriter
        require wrapper
    Writer
        is an abstract class not interface
    p1.resolve(p2)
        if p1 is relative path and p2 is an absolute path => return p2
        if p1 is absolute path and p2 is an relative path => return p1 append p2
        if p1 and p2 are absolute path => return p1 append p2
    p1.relativize(p2)
        both p1 and p2 should be either relative or absolute
    If System.err is closed, no exception will be thrown evenwhen there's exception
    FileInput
        doesn't have readLine-
    Path
        index star from 0
    Constructor of the class for an object being deserialized is never invoked except for record classes. This is secure because record class can validate the values before assign them to field

Database
    You can use setNull but it required you to set datatype
    Driver is responsible for getting connection to Database
    if store procedure return value, should use execute()
    It's ok to set param 1 and executeUpdate() 2 times
        Example
            var sql = "INSERT INTO abc(color,name) values (?,?)"
            var st = conn.prepareStatement(sql)
            st.setString(1,"234");
            st.setString(2,"abc");
            st.executeUpdate();

            st.setString(1,"456");
            st.executeUpdate(); /// still work with value 1 is 456 and 2 is abc
   When in auto commit mode, the statement commit immediately evenwhen you set the auto commit to false before and then set it to true
   ResultSet doesn't has hasNext() method but next() method
   execute() return boolean unlike executeQuery() return ResultSet

Localization
    Resource Bundle
        The resource gonna use request locale
            If it have, it move from request locale -> requested language code -> default properties
            IF it doesn't have, it move to default locale -> default language code locale -> default properties
